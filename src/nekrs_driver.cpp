#include "enrico/nekrs_driver.h"
#include "enrico/error.h"
#include "gsl.hpp"
#include "iapws/iapws.h"
#include "nekInterfaceAdapter.hpp"
#include "nekrs.hpp"

// Generated by ENRICO's CMakeLists.  Defines NEKRS_HOME as CMAKE_INSTALL_PREFIX
#include "nekrs_home.h"

#include <algorithm>
#include <dlfcn.h>

namespace enrico {
NekRSDriver::NekRSDriver(MPI_Comm comm, pugi::xml_node node)
  : HeatFluidsDriver(comm, node)
{
  if (active()) {
    // Force NEKRS_HOME
    std::stringstream msg;
    msg << "Setting env variable NEKRS_HOME=" << NEKRS_HOME;
    comm_.message(msg.str());
    err_chk(setenv("NEKRS_HOME", NEKRS_HOME, 1) == 0,
            "Could not set env variable NEKRS_HOME");

    // See vendor/nekRS/src/core/occaDeviceConfig.cpp for valid keys
    setup_file_ = node.child_value("casename");
    nekrs::setup(
        comm /* comm_in */,
        0 /* buildOnly */, 
        0 /* sizeTarget */, 
        0 /* ciMode */, 
        "" /* cacheDir */, 
        setup_file_ /* _setupFile */, 
        "" /* backend_ */, 
        "" /* _deviceId */);

    nrs_ptr_ = reinterpret_cast<nrs_t *>(nekrs::nrsPtr());

    open_lib_udf();

    // Check that we're running a CHT simulation.
    err_chk(nrs_ptr_->cht == 1,
            "NekRS simulation is not setup for conjugate-heat transfer (CHT).  "
            "ENRICO must be run with a CHT simulation.");

    // Local and global element counts
    n_local_elem_ = nrs_ptr_->cds->mesh[0]->Nelements;
    std::size_t n = n_local_elem_;
    MPI_Allreduce(
      &n, &n_global_elem_, 1, get_mpi_type<std::size_t>(), MPI_SUM, comm_.comm);

    n_gll_ = nrs_ptr_->cds->mesh[0]->Np;
    x_ = nrs_ptr_->cds->mesh[0]->x;
    y_ = nrs_ptr_->cds->mesh[0]->y;
    z_ = nrs_ptr_->cds->mesh[0]->z;

    element_info_ = nrs_ptr_->cds->mesh[0]->elementInfo;

    // rho energy is field 1 (0-based) of rho
    rho_cp_ = &nrs_ptr_->cds->prop[nrs_ptr_->cds->fieldOffsetSum];

    temperature_ = nrs_ptr_->cds->S;

    mass_matrix_ = nrs_ptr_->cds->mesh[0]->LMM;

    init_displs();
  }
  comm_.Barrier();
}

void NekRSDriver::init_step()
{
  auto min = std::min_element(localq_->cbegin(), localq_->cend());
  auto max = std::max_element(localq_->cbegin(), localq_->cend());
}

void NekRSDriver::solve_step()
{
  if (comm_.active()) {
    comm_.Barrier();
  }
  auto elapsed_time = MPI_Wtime();

  const int runtime_stat_freq = 500;
  tstep_ = 0;
  time_ = nekrs::startTime();
  auto last_step = nekrs::lastStep(time_, tstep_, elapsed_time);

  nekrs::udfExecuteStep(time_, tstep_, /* outputStep */ 0);

  if (!last_step) {
    std::stringstream msg;
    if (nekrs::endTime() > nekrs::startTime()) {
      msg << "timestepping to time " << nekrs::endTime() << " ...";
    } else {
      msg << "timestepping for " << nekrs::numSteps() << " steps ...";
    }
    comm_.message(msg.str());
  }

  while (!last_step) {
    if (comm_.active()) {
      comm_.Barrier();
    }
    const auto time_start = MPI_Wtime();

    ++tstep_;
    last_step = nekrs::lastStep(time_, tstep_, elapsed_time);

    double dt;
    if (last_step && nekrs::endTime() > 0) {
      dt = nekrs::endTime() - time_;
    } else {
      dt = nekrs::dt();
    }

    auto output_step = nekrs::outputStep(time_ + dt, tstep_);
    if (nekrs::writeInterval() == 0) {
      output_step = 0;
    }
    if (last_step) {
      output_step = 1;
    }
    if (nekrs::writeInterval() < 0) {
      output_step = 0;
    }

    nekrs::runStep(time_, dt, tstep_);
    time_ += dt;

    if (output_step) {
      nekrs::outfld(time_);
    }

    if (tstep_ % runtime_stat_freq == 0 || last_step)
      nekrs::printRuntimeStatistics();

    if (comm_.active()) {
      comm_.Barrier();
    }
    elapsed_time += (MPI_Wtime() - time_start);
  } // while(!last_step)
}

void NekRSDriver::write_step(int timestep, int iteration) { return; }

Position NekRSDriver::centroid_at(int32_t local_elem) const
{
  Expects(local_elem < n_local_elem());
  Position c{0., 0., 0.};
  double mass = 0.;
  for (gsl::index i = 0; i < n_gll_; ++i) {
    auto idx = local_elem * n_gll_ + i;
    c.x += x_[idx] * mass_matrix_[idx];
    c.y += y_[idx] * mass_matrix_[idx];
    c.z += z_[idx] * mass_matrix_[idx];
    mass += mass_matrix_[idx];
  }
  c.x /= mass;
  c.y /= mass;
  c.z /= mass;
  return c;
}

std::vector<Position> NekRSDriver::centroid_local() const
{
  std::vector<Position> c(n_local_elem());
  for (int32_t i = 0; i < n_local_elem(); ++i) {
    c[i] = this->centroid_at(i);
  }
  return c;
}

double NekRSDriver::volume_at(int32_t local_elem) const
{
  Expects(local_elem < n_local_elem());
  double v = 0.;
  for (int32_t i = 0; i < n_gll_; ++i) {
    v += mass_matrix_[local_elem * n_gll_ + i];
  }
  return v;
}

std::vector<double> NekRSDriver::volume_local() const
{
  std::vector<double> v(n_local_elem());
  for (int32_t i = 0; i < n_local_elem(); ++i) {
    v[i] = this->volume_at(i);
  }
  return v;
}

double NekRSDriver::temperature_at(int32_t local_elem) const
{
  Expects(local_elem < n_local_elem());

  double sum0 = 0.;
  double sum1 = 0.;
  for (int32_t i = 0; i < n_gll_; ++i) {
    auto idx = local_elem * n_gll_ + i;
    sum0 += rho_cp_[idx] * temperature_[idx];
    sum1 += rho_cp_[idx];
  }
  return sum0 / sum1;
}

std::vector<double> NekRSDriver::temperature_local() const
{
  std::vector<double> t(n_local_elem());
  for (int32_t i = 0; i < n_local_elem(); ++i) {
    t[i] = this->temperature_at(i);
  }

  return t;
}

std::vector<double> NekRSDriver::density_local() const
{
  nek::copyToNek(time_, tstep_);
  std::vector<double> local_densities(n_local_elem());

  for (int32_t i = 0; i < n_local_elem(); ++i) {
    if (this->in_fluid_at(i) == 1) {
      auto T = this->temperature_at(i);
      // nu1 returns specific volume in [m^3/kg]
      local_densities[i] = 1.0e-3 / iapws::nu1(pressure_bc_, T);
    } else {
      local_densities[i] = 0.0;
    }
  }

  return local_densities;
}

int NekRSDriver::in_fluid_at(int32_t local_elem) const
{
  // In NekRS, element_info_[i] == 1 if i is a *solid* element
  Expects(local_elem < n_local_elem());
  return element_info_[local_elem] == 1 ? 0 : 1;
}

std::vector<int> NekRSDriver::fluid_mask_local() const
{
  std::vector<int> mask(n_local_elem());
  for (int32_t i = 0; i < n_local_elem(); ++i) {
    mask[i] = in_fluid_at(i);
  }
  return mask;
}

int NekRSDriver::set_heat_source_at(int32_t local_elem, double heat)
{
  for (int i = 0; i < n_gll_; ++i) {
    localq_->at(local_elem * n_gll_ + i) = heat;
  }
  return 0;
}

void NekRSDriver::open_lib_udf()
{
  lib_udf_handle_ = dlopen(lib_udf_name_.c_str(), RTLD_LAZY);
  if (!lib_udf_handle_) {
    std::stringstream msg;
    msg << "dlopen error for localq in " << lib_udf_name_ << " : " << dlerror();
    throw std::runtime_error(msg.str());
  }
  void* localq_void = dlsym(lib_udf_handle_, "localq");
  if (dlerror()) {
    throw std::runtime_error("dlsym error for localq in " + lib_udf_name_);
  }
  localq_ = reinterpret_cast<std::vector<double>*>(localq_void);
}

void NekRSDriver::close_lib_udf()
{
  err_chk(dlclose(lib_udf_handle_), "dlclose error for " + lib_udf_name_);
}

NekRSDriver::~NekRSDriver()
{
  close_lib_udf();
}

}
