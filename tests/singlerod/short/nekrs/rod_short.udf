//
// nekRS User Defined File
//
#include "udf.hpp"
#include <math.h>

static occa::kernel cFillKernel;
static occa::kernel cCopyKernel;
static int updateProperties = 1;

void userq(nrs_t* nrs, dfloat time, occa::memory o_S, occa::memory o_FS)
{
  auto mesh = nrs->cds->mesh;
  // TODO: Check to see if we can copy from o_S instead
  o_FS.copyFrom(&nrs->cds->S[nrs->cds->fieldOffset * sizeof(dfloat)],
                mesh->Nelements * mesh->Np * sizeof(dfloat),
                0);
}

void uservp(nrs_t* nrs,
            dfloat time,
            occa::memory o_U,
            occa::memory o_S,
            occa::memory o_UProp,
            occa::memory o_SProp)
{
  cds_t* cds = nrs->cds;

  if (updateProperties) {
    const dfloat rho = 1.0;
    const dfloat mue = 0.01;
    const dfloat rhoCpFluid = rho * 1.0;
    const dfloat conFluid = mue;
    const dfloat rhoCpSolid = rhoCpFluid * 0.01;
    const dfloat conSolid = 10 * conFluid;

    // velocity
    const occa::memory o_mue = o_UProp.slice(0 * nrs->fieldOffset * sizeof(dfloat));
    const occa::memory o_rho = o_UProp.slice(1 * nrs->fieldOffset * sizeof(dfloat));
    cFillKernel(nrs->mesh->Nelements, mue, 0, nrs->mesh->o_elementInfo, o_mue);
    cFillKernel(nrs->mesh->Nelements, rho, 0, nrs->mesh->o_elementInfo, o_rho);
    // temperature
    const occa::memory o_con = o_SProp.slice(0 * cds->fieldOffset * sizeof(dfloat));
    const occa::memory o_rhoCp = o_SProp.slice(1 * cds->fieldOffset * sizeof(dfloat));

    double* nekScratch = nekData.cbscnrs;
    o_SProp.copyFrom(nekScratch, cds->Nlocal * sizeof(dfloat), 0);

    cFillKernel(cds->mesh->Nelements, conFluid, conSolid, nrs->mesh->o_elementInfo, o_con);
    cFillKernel(
      cds->mesh->Nelements, rhoCpFluid, rhoCpSolid, nrs->mesh->o_elementInfo, o_rhoCp);
    updateProperties = 0;
  }
}

/* UDF Functions */

void UDF_LoadKernels(nrs_t* nrs)
{
  cFillKernel = udfBuildKernel(nrs, "cFill");
  cCopyKernel = udfBuildKernel(nrs, "cCopy");
}

void UDF_Setup(nrs_t* nrs)
{
  nrs->o_usrwrk.free();
  free(nrs->usrwrk);
  nrs->usrwrk = (dfloat*)calloc(nrs->mesh->Nelements * nrs->mesh->Np, sizeof(dfloat));
  nrs->o_usrwrk = nrs->mesh->device.malloc(
    nrs->mesh->Nelements * nrs->mesh->Np * sizeof(dfloat), nrs->usrwrk);

  nek_userchk();

  auto* wrk1 = nekData.cbscnrs;
  nrs->o_usrwrk.copyFrom(wrk1, nrs->mesh->Nelements * nrs->mesh->Np * sizeof(dfloat));

  udf.sEqnSource = &userq;
  udf.properties = &uservp;
}

void UDF_ExecuteStep(nrs_t* nrs, dfloat time, int tstep)
{
  if (nrs->isOutputStep) {
    nek_ocopyFrom(time, tstep);
    nek_userchk();
    auto* wrk1 = nekData.cbscnrs;
    nrs->o_usrwrk.copyFrom(wrk1, nrs->mesh->Nelements * nrs->mesh->Np * sizeof(dfloat));
    updateProperties = 1;
  }
}
