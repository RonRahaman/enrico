//
// nekRS User Defined File
//
#include "nekInterfaceAdapter.hpp"
#include "udf.hpp"
#include <math.h>
#include <vector>

// We use std::vector (not dfloat*)
// * Must get resized in UDF_Setup (see below)
// * Will get automatically destroyed
std::vector<dfloat> localq;

static occa::kernel cFillKernel;
static occa::kernel cCopyKernel;
static int updateProperties = 1;

void userq(nrs_t* nrs, dfloat time, occa::memory o_S, occa::memory o_FS)
{
  auto mesh = nrs->cds->mesh[0];
  o_FS.copyFrom(localq.data(), mesh->Nelements * mesh->Np * sizeof(dfloat), 0);

}

void uservp(nrs_t* nrs,
            dfloat time,
            occa::memory o_U,
            occa::memory o_S,
            occa::memory o_UProp,
            occa::memory o_SProp)
{
  cds_t* cds = nrs->cds;

  if (updateProperties) {
    const dfloat rho = 1.0;
    const dfloat mue = 0.01;
    const dfloat rhoCpFluid = rho * 1.0;
    const dfloat conFluid = mue;
    const dfloat rhoCpSolid = rhoCpFluid * 0.01;
    const dfloat conSolid = 10 * conFluid;

    // velocity
    const occa::memory o_mue = o_UProp.slice(0 * nrs->fieldOffset * sizeof(dfloat));
    const occa::memory o_rho = o_UProp.slice(1 * nrs->fieldOffset * sizeof(dfloat));
    cFillKernel(nrs->meshV->Nelements, mue, 0, nrs->meshV->o_elementInfo, o_mue);
    cFillKernel(nrs->meshV->Nelements, rho, 0, nrs->meshV->o_elementInfo, o_rho);
    // temperature
    const occa::memory o_con = o_SProp.slice(0 * cds->fieldOffset[0] * sizeof(dfloat));
    const occa::memory o_rhoCp = o_SProp.slice(1 * cds->fieldOffset[0] * sizeof(dfloat));

    double* nekScratch = nekData.cbscnrs;
    o_SProp.copyFrom(nekScratch, cds->mesh[0]->Nlocal * sizeof(dfloat), 0);

    cFillKernel(
      cds->mesh[0]->Nelements, conFluid, conSolid, nrs->meshV->o_elementInfo, o_con);
    cFillKernel(cds->mesh[0]->Nelements,
                rhoCpFluid,
                rhoCpSolid,
                nrs->meshV->o_elementInfo,
                o_rhoCp);
    updateProperties = 0;
  }
}

/* UDF Functions */

void UDF_LoadKernels(nrs_t* nrs)
{
  cFillKernel = udfBuildKernel(nrs, "cFill");
  cCopyKernel = udfBuildKernel(nrs, "cCopy");
}

void UDF_Setup(nrs_t* nrs)
{
  platform_t* plat = platform_t::getInstance();

  // nrs->o_usrwrk.free();
  // free(nrs->usrwrk);

  nrs->usrwrk = (dfloat*)calloc(nrs->meshV->Nelements * nrs->meshV->Np, sizeof(dfloat));
  nrs->o_usrwrk = plat->device.malloc(
    nrs->meshV->Nelements * nrs->meshV->Np * sizeof(dfloat), nrs->usrwrk);

  nek::userchk();

  auto* wrk1 = nekData.cbscnrs;
  nrs->o_usrwrk.copyFrom(wrk1, nrs->meshV->Nelements * nrs->meshV->Np * sizeof(dfloat));

  udf.sEqnSource = &userq;
  udf.properties = &uservp;

  // ATTENTION: Need to explicitly resize localq
  localq.resize(nrs->cds->mesh[0]->Nelements * nrs->cds->mesh[0]->Np);
}

void UDF_ExecuteStep(nrs_t* nrs, dfloat time, int tstep)
{
  if (nrs->isOutputStep) {
    nek::ocopyFromNek(time);
    nek::userchk();
    auto* wrk1 = nekData.cbscnrs;
    nrs->o_usrwrk.copyFrom(wrk1, nrs->meshV->Nelements * nrs->meshV->Np * sizeof(dfloat));
    updateProperties = 1;
  }
}
