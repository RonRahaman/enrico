c-----------------------------------------------------------------------
C
C  USER SPECIFIED ROUTINES:
C
C     - boundary conditions
C     - initial conditions
C     - variable properties
C     - local acceleration for fluid (a)
C     - forcing function for passive scalar (q)
C     - general purpose routine for checking errors etc.
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,ie)
      include 'SIZE'
      include 'TOTAL'
      return
      end  

      subroutine uservpnek (rdiff,ix,iy,iz,e)
      include 'SIZE'
      include 'TOTAL'

      integer e,f,ix,iy,iz
      real t_,rdiff

      rdiff  = 0.01

      xx = xm1(ix,iy,iz,e)
      yy = ym1(ix,iy,iz,e)
      rr = sqrt(xx**2+yy**2)

      ! temperature in K, assumed constant temperature first
      t_ = t(ix,iy,iz,e,1)

      if (rr.lt.0.406) then
          ! fuel conductivity in W/cm-K
          rdiff = 1.0/(4.52 + 2.46e-2*t_) + 3.5e7/(t_*t_) *
     $            exp(-16361.0/t_)
      else if (rr.lt.0.414) then
          rdiff  = 0.0001  ! gap conductivity in W/cm-K
      else if (rr.lt.0.475) then
          rdiff  = 0.13  ! clad conductivity in W/cm-K
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,f,eg
      ffx=0.0
      ffy=0.0
      ffz=0.0
      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      common/imaterial/i_mate(lelt)
      integer i_mate

      common /scrach_o2/
     & con_array(lx1,ly1,lz1,lelv)
      COMMON /SCNRS/ SC_NRS(LX1*LY1*LZ1*LELT*7)
      real           SC_NRS,con_array,rdiff
      integer e,i,j,k,n

      n=lx1*ly1*lz1*nelt

      tmin=glmin(t,n)
      tmax=glmax(t,n)
 
      if (nid.eq.0) then
       write(6,*)" > Temperature: ",tmin," - ",tmax
      endif

      do e=1,nelt 
      do k=1,lz1
      do j=1,ly1
      do i=1,lx1
        call uservpnek(rdiff,i,j,k,e) 
        con_array(i,j,k,e)=rdiff 
      enddo
      enddo
      enddo 
      enddo 

      do i=1,n
        sc_nrs(i)=con_array(i,1,1,1)
      enddo  

c     Set i_mate array.  For this case, only for volume check in ENRICO

      do e=1,nelt
         if (e.le.nelv) then
             i_mate(e)=0
         else
            xx = xm1(1,1,1,e)
            yy = ym1(1,1,1,e)
            rr = sqrt(xx**2+yy**2)
            if (rr.lt.0.406) then
c              Fuel
               i_mate(e) = 1
            else if (rr.lt.0.414) then
c              Gap
               i_mate(e) = 2
            else if (rr.lt.0.475) then
c              Cladding
               i_mate(e) = 3
            endif
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer idum, e
      save    idum
      data    idum / 0 /

      if (idum.eq.0) idum = 99 + nid
      eps = .35

      uz=50.0
      uy=0.0
      ux=0.0
      temp=523.15

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      n=lx1*ly1*lz1*nelt

      xx1=glmax(xm1,n)
      xx2=glmin(xm1,n)
      yy1=glmax(ym1,n)
      yy2=glmin(ym1,n)  

      ! reconstruct boundary tags
      do iel=1,nelv
      do ifc=1,2*ndim
      call surface_int(sint,sarea,xm1,iel,ifc)
      xx=sint/sarea
      call surface_int(sint,sarea,ym1,iel,ifc)
      yy=sint/sarea
      if (cbc(ifc,iel,1) .eq. 'v  ') boundaryID(ifc,iel) = 1
      if (cbc(ifc,iel,1) .eq. 'O  ') then
          boundaryID(ifc,iel) = 2
          cbc(ifc,iel,2) = cbc(ifc,iel,1) 
      endif
      if (cbc(ifc,iel,1) .eq. 'W  ') boundaryID(ifc,iel) = 3
      if (cbc(ifc,iel,1) .eq. 'SYM') then
      if ((abs(xx-xx1).lt.1e-4).or.(abs(xx-xx2).lt.1e-4)) then   
                boundaryID(ifc,iel) = 4
      endif
      if ((abs(yy-yy1).lt.1e-4).or.(abs(yy-yy2).lt.1e-4)) then         
                boundaryID(ifc,iel) = 5
      endif
      endif
      enddo
      enddo

      do iel=1,nelt
      do ifc=1,2*ndim
      call surface_int(sint,sarea,xm1,iel,ifc)
      xx=sint/sarea
      call surface_int(sint,sarea,ym1,iel,ifc)
      yy=sint/sarea
      if (cbc(ifc,iel,2) .eq. 't  ') boundaryIDt(ifc,iel) = 1
      if (cbc(ifc,iel,2) .eq. 'O  ') boundaryIDt(ifc,iel) = 2      
      if (cbc(ifc,iel,2) .eq. 'I  ') boundaryIDt(ifc,iel) = 3
      if ((abs(xx-xx1).lt.0.0001).or.(abs(xx-xx2).lt.0.0001)) then          
                boundaryIDt(ifc,iel) = 4
      endif
      if ((abs(yy-yy1).lt.0.0001).or.(abs(yy-yy2).lt.0.0001)) then 
                boundaryIDt(ifc,iel) = 5
      endif
      enddo
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
